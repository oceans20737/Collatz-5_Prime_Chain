#!/usr/bin/env python
# coding: utf-8

# In[ ]:


# Copyright (c) 2026 Hiroshi Harada
# Licensed under the MIT License.
# https://opensource.org/licenses/MIT

"""
Prime Chain Discovery in the Extended 5-adic Collatz-like Map
Author: Hiroshi Harada
Date: February 25, 2026
License: MIT

This script performs a parallelized search for prime chains generated by the extended 5-adic Collatz-like function:

    f(n) = (6n + c) / 5

The constant c ∈ {−3, −1, +1, +3} is selected based on n mod 5 to ensure the numerator is divisible by 5 and remains odd.
This parity-preserving approach avoids even-number traps and increases the likelihood of generating long chains of odd primes.

Requirements:
- Python 3.6+
- sympy

To install dependencies:
    pip install sympy

To run the search over the first 100 million odd integers:
    python hunt_5adic.py
"""

import multiprocessing as mp
from sympy import isprime
import time

def get_next_5adic_custom(n):
    """
    Computes the next value in the extended 5-adic Collatz-like sequence.
    The constant c is chosen based on n mod 5 to ensure (6n + c) is divisible by 5.
    """
    rem = n % 5
    if rem == 1: return (6 * n - 1) // 5
    if rem == 2: return (6 * n + 3) // 5
    if rem == 3: return (6 * n - 3) // 5
    if rem == 4: return (6 * n + 1) // 5
    return None  # Invalid case when n ≡ 0 mod 5

def check_range(start, end):
    """
    Searches for prime chains within the given range [start, end).
    Only odd starting values are considered.
    Returns a list of tuples: (chain length, chain list)
    """
    results = []
    for n0 in range(start | 1, end, 2):  # Skip even numbers
        if not isprime(n0):
            continue

        chain = []
        history = set()
        curr = n0

        while curr not in history:
            if not isprime(curr):
                break
            chain.append(curr)
            history.add(curr)

            nxt = get_next_5adic_custom(curr)
            if nxt is None or nxt % 2 == 0:
                break
            curr = nxt

        if len(chain) >= 6:
            results.append((len(chain), chain))
    return results

def fast_hunt_5adic(total_range=100_000_000):
    """
    Launches a parallelized search for prime chains up to total_range.
    Utilizes all available CPU cores for efficient computation.
    """
    start_time = time.time()
    cores = mp.cpu_count()
    chunk = total_range // cores

    print(f"--- 5-adic Full-Auto Hunt ---")
    print(f"[*] Range: 3 to {total_range:,}")
    print(f"[*] Cores Engaged: {cores}")

    with mp.Pool(cores) as pool:
        tasks = [(i * chunk, (i + 1) * chunk) for i in range(cores)]
        all_res = pool.starmap(check_range, tasks)

    found_count = 0
    for res_list in all_res:
        for length, chain in res_list:
            print(f"\n[!] Hit! L{length} at n0={chain[0]}")
            print(f"    Chain: {chain}")
            found_count += 1

    print(f"\n--- Hunt Complete ({time.time() - start_time:.2f}s) ---")
    print(f"Total L6+ chains discovered: {found_count}")

if __name__ == "__main__":
    # Deep scan into the first 100 million odd integers
    fast_hunt_5adic(100_000_000)


# In[ ]:




